1.客户端向服务器发起方法同步调用

客户端使用<nettyrpc:reference/>标签：

<nettyrpc:reference/>属性如下：
1）.interfaceName：要使用的服务
2）.ipAddr：要连接的服务器IP地址和端口号
3）.protocol：传输数据所使用的序列化协议

在客户端Spring IoC容器启动的过程中，会初始化client.xml文件中的bean，由于<nettyrpc:reference/>标签对应的NettyRpcReference类实现了InitializingBean
接口，因此会回调其中的afterProperties方法。在此方法中，会和服务器建立连接，如果连接建立失败，则每过10s再尝试一下。

接着，由于NettyRpcReference类实现了FactoryBean接口，因此通过ctx.getBean获取Spring容器中的bean对象时，实际上获取到的是NettyRpcReference
类中getObject方法返回的对象，即一个实现了interfaceName接口的代理对象。

PersonManage manage = (PersonManage) context.getBean("personManage");
manage.save(p);

比如上面的代码，返回的manage对象实际上是一个代理对象，调用它的save方法最终会调用MessageSendProxy类中的invoke方法。MessageSendProxy实现了
InvocationHandler接口。

在MessageSendProxy#invoke方法中，会把调用请求包装成一个MessageRequest对象，然后发送到服务器端。注意，这里客户端向服务器端发起的调用是同步调用，
所以，客户端在发起调用后会阻塞，直到服务器端把结果返回。客户端默认阻塞的时间不超过30s，如果超过30s后，还没有接收返回的结果，那么就会抛出InvokeTimeoutException异常。

2.服务器处理客户端调用

服务器在接收到客户端的请求之后，会把请求调用的具体执行包装成一个Task，然后放入到线程池中去执行。这里的Task分为两种：

i.MessageRecvInitializeTask（开启了JMX监控）
ii.MessageRecvInitializeTaskAdapter（没有开启JMX监控）

我们这里不讨论JMX相关的内容。这两种类型的Task都继承了AbstractMessageRecvInitializeTask类，而AbstractMessageRecvInitializeTask实现了Callable接口。
在线程池执行AbstractMessageRecvInitializeTask，对客户端要求调用的方法的执行分为以下5个步骤：

1）如果用户配置了ChainFilter的话（一般配置多个），那么就会首先将这些ChainFilter封装成ChainFilterInvoker对象，并且连接成一个类似于链表的结构。
然后调用请求会先经过这些ChainFilter的处理，最后才会去调用实际的方法。

2）对于实际方法的调用又通过Spring AOP的方式对其进行了增强。这里增强的目的主要是调用用户配置的过滤器filter。在调用实际方法之前，先调用配置的filter中的before方法，用来对客户端
请求进行处理。如果用户没有配置过滤器的话（默认是没有的），那么就通过反射直接调用方法，然后返回结果。

3）调用实际方法

4）接着调用filter中的after方法，可以进行一些统计或者日志方面的工作。

5）返回方法调用的结果

注意，这里所说的过滤器filter，是配置在<nettyrpc:service/>标签的filter属性中的，实现了Filter接口的类对象。所以是对每一个单独的bean起作用。

但是，如果是在XML文件中配置了多个ChainFilter对象，这些ChainFilter对于客户端的每次调用都有效，可以说是全局的，并且是在每次调用请求到来时生成。
