netty-rpc项目中的JMX检测的大致流程如下所示：

1.开启JMX监控

首先，在自定义的Spring标签<nettyrpc:registry/>中，它对应的bean为NettyRpcRegistry类对象。这个bean实现了InitializingBean这个接口，因此在这个
bean创建成功之后，会回调其afterProperties方法，这个方法主要完成两个功能：让服务开始监听客户端发起rpc调用的ip地址和端口号、监听服务能力展示开放端口、
启动JMX监控（如果用户配置了JMX监控的话）。

监控的开启具体由ModuleMetricsHandler中的start方法完成。首先从JMX的角度看，ModuleMetricsHandler本身就是一个MXBean，或者说一个管理构件，
用来代表一个被管理的资源实例，具体表现为它实现了ModuleMetricsVisitorMXBean接口。

在ModuleMetricsVisitorMXBean接口中，定义了如下两个方法：
i.getModuleMetricsVisitor：说明ModuleMetricsVisitorMXBean对象拥有属性：ModuleMetricsVisitor
ii.addModuleMetricsVisitor：拥有行为：addModuleMetricsVisitor

在start方法中我们把ModuleMetricsHandler对象本身注册到MBeanServer中，并且在handler上添加一个监听器ModuleMetricsListener。当调用handler#sendNotification
方法时，就会把事件发送给监听器ModuleMetricsListener。在ModuleMetricsListener监听器中，根据传送过来的事件类型，进行具体的操作，比如为InvokeEvent，
那么就将visitor中关于方法的调用次数增加一；若为InvokeSuccEvent，那么就将visitor中关于方法的调用成功的次数增加一。

在netty-rpc项目中，开启了JMX监控之后，有两处用到了JMX监控，一处是JMX的通知机制，根据方法调用的不同情况，会触发各种不同的事件，这些事件会被发往JMX的
监听器进行处理；第二处，就是在ModuleMetricsHtmlBuilder类中，通过getAttribute的方式获取到visitorList集合，从而将服务器中各个方法的调用情况显示出来。

2.客户端发起Rpc调用

在客户端发起Rpc调用时，我们这里以调用AddCalculate#add方法为例。如果客户端有多个线程同时发送调用请求，Rpc服务器的MessageRecvHandler
会接收到多个MessageRequest请求，然后会依据用户是否开启JMX创建不同的task。然后放入到线程池中去具体执行。

这些task创建完毕之后，放入到线程池里面去执行，这么做的原因是可能是业务方法（比如add方法）的执行时间会很长，导致Netty中的Reactor的worker
线程一直忙于执行业务，从而使其它任务堆积得不到响应。

在MessageRecvHandler#channelRead方法中，创建的这些task，都是AbstractMessageRecvInitializeTask的子类，它们都实现了Callable接口。
它们的具体类型如下所示：

1）如果用户开启了JMX监控就返回MessageRecvInitializeTask；
2）如果用户没有开启JMX监控，就直接返回MessageRecvInitializeTaskAdapter；

这些task的主要任务如下（以MessageRecvInitializeTask为例）：

1）调用injectInvoke方法

在这个方法中，首先会获取到和客户端要调用方法对应的ModuleMetricsVisitor，在获取visitor的时候，要进行并发控制，使得每个方法都和visitor一一对应，
不能出现同一个方法与多个visitor对应的情况。

然后通过JMX的通知机制，将InvokeEvent传递给注册在ModuleMetricsHandler上的监听器，将ModuleMetricsVisitor中和方法调用次数相关的属性invokeCount增加1，
这个ModuleMetricsVisitor对应于AddCalculate#add方法。

2）利用反射获取到用户要调用的方法，执行方法并且获取到调用的结果。

3）如果调用成功，调用injectSuccInvoke方法

修改ModuleMetricsVisitor中的属性：invokeSuccCount、accumulateTimespan、invokeMinTimespan、invokeMaxTimespan，分别代表方法调用成功的次数、
累积耗时、最大耗时、最小耗时；

4）如果调用失败，调用injectFailInvoke方法

修改ModuleMetricsVisitor中的属性：方法调用的失败次数、方法调用最后一次失败的时间以及最后一次失败的堆栈明细；

5）如果调用被拦截，调用injectFilterInvoke方法

修改ModuleMetricsVisitor中的属性：方法被拦截的次数。

注意，在ModuleMetrcisListener中修改ModuleMetricsVisitor中的属性时，由于可能有多个线程都同时获取到同一个visitor对象，因此修改其中属性也要进行并发控制，
在ModuleMetricsVisitor中主要使用的是CAS机制。

3.通过浏览器获取方法调用的详细数据

用户可以通过JConsole的方法或者浏览器的方式。在服务器内部，有一个小型的HTTP服务器，可以接收HTTP请求，返回HTTP响应。在ApiHandler#buildResponseMsg
中，返回构建的HTTP响应文本。具体如下：

1）如果用户开启了JMX监控的话，就调用ModuleMetricsHtmlBuilder#buildModuleMetrics方法，来获取RPC服务器中方法调用的具体数据
2）如果用户没有开启JMX监控的话，就会返回一个error信息

