介绍一下异步调用的大概逻辑：

首先，我们需要创建一个实现AsyncCallback接口的对象，在对象的call方法中写入我们具体的业务逻辑代码，通常是要求调用服务器端的某些代码，但是我们又不想使用同步的方式。
另外，AsyncCallback<T>中的泛型参数T通常是call方法的返回结果，也就是我们调用服务器方法所返回的结果。

接着，通过AsyncInvoker#submit方法，把实现了AsyncCallback接口的对象封装成一个FutureTask对象，然后放入到线程池中去执行。也就是说，我们
调用服务器的方法是在其它线程中被执行的，并且还是采用同步执行的，但不是在main线程中。我们以AsyncRpcCallTest中的calculate.calculate为例，
calculate.calculate还是会在线程池的线程中进行同步调用，也就是在MessageSendProxy中，将方法调用包装成一个MessageRequest对象，发送给服务器，然后阻塞等待结果。

在前面把实现了AsyncCallback接口的对象submit给AsyncInvoker对象之后，就会返回一个对象，这个对象通常是一个CGLIB代理对象。只不过这个代理对象会
实现AsyncCallObject接口，同时继承了AsyncCallback<T>中T所表示类，然后将这个代理对象返回。还是以AsyncRpcCallTest中代码为例，AsyncInvoker#submit
返回elapse0，这个elapse0是一个CGLIB代理对象，它实现了AsyncCallObject接口，也继承了CostTime类。

当使用elapse0调用AsyncCallObject接口中的_getStatus方法时，会将调用转发给AsyncLoadStatusInterceptor中的intercept方法，然后根据封装好的FutureTask
对象来获取到我们所写的调用代码在线程池中的状态是什么。

当elapse0调用除_getStatus之外的其它方法（比如setDetail方法）时，就会将调用转发给AsyncLoadResultInterceptor中的intercept方法。此时调用会阻塞
（因为调用前面的FutureTask#get方法），以获取到我们业务代码真正的调用返回对象，然后再在这个返回对象上调用setDetail方法。

总结：

我们把要异步调用的方法写入AsyncCallback中的call方法中，然后AsyncInvoker会把此AsyncCallback对象会被封装成一个FutureTask对象，然后放入到线程池里面去执行，
也就是由线程池中的其它线程来真正向服务器发起调用，而不是当前线程，线程池中的线程在发起调用的时候还是采取同步调用的方式，会阻塞。然后AsyncInvoker#submit返回
一个代理对象，此对象实现了AsyncCallObject接口，同时也继承了AsyncCallback<T>中的T参数。

当我们要调用代理对象的_getStatus方法和其它方法时，分开进行执行。调用_getStatus会返回客户端向服务器发起调用的状态；调用其它方法，可能会阻塞直到我们向服务器的调用、
返回真正的结果对象，然后再利用此结果对象来调用具体的方法。